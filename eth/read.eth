(package eth/reader (read)

(import "./helpers" (unescape-string))

(def EOF "__eth__eof")

;; helpers

(defn newline? (ch)
  (== ch "\n"))

(defn reader-error (reader message)
  "Create and throws a new reader error that include file and position information"
  (let ((text (string message "\nline:" reader.line "\ncolumn:" reader.column))
        (error (SyntaxError text reader.filename)))
    (set error.line reader.line)
    (set error.column reader.column)
    (set error.filename reader.filename)
    (throw error)))


;; reader

(defn create-reader (filename source)
  "Create a reader object that keeps track of a position in a source file"
  {:lines (split "\n" source)
   :filename filename
   :column -1
   :line 0})

(defn peek-char (reader)
  "Returns the next char to be read (or nil) but doesn't advance the current position"
  (let ((line (get reader.line reader.lines))
        (next-column (inc reader.column)))
    (if (undefined? line)
      undefined
      (or (get next-column line) "\n"))))

(defn read-char (reader)
  "Returns the next char for the reader and advances it's position"
  (let ((ch (peek-char reader)))
    (if (newline? ch)
      (do
        (set reader.line (inc reader.line))
        (set reader.column -1))
      (set reader.column (inc reader.column)))
    ch))


;; types

(def read-string (reader)
  (loop ((buffer "")
         (ch (read-char reader)))
    (if (undefined? char) EOF
    (if (&& (== ch "\"") (!= (last buffer) "\\")) (unescape-string buffer)
    (recur (append ch buffer) (read-char reader))))))


;; read

(defn read! (reader)
  (let ((ch (read-char reader)))
    (if (== ch "\"") (read-string reader)
      (reader-error reader (string "Unhandled character encountered " ch)))))

(defn read (filename source)
  (let ((reader (create-reader filename source)))
    (loop (ast-nodes [])
      (let ((node (read! reader)))
        (if (== node EOF)
          (ast-nodes)
          (recur (append node ast-nodes)))))))

)
