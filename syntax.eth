(import ramda R)
(import "./ast" ast)

; Quotes the given AST preventing it's evaluation. This is, while taking care of honoring
; unquotes and unquote-splicings
(defmacro quote (node)
  (def L ast.list)
  (def S ast.symbol)

  ; Takes a node a unquote it, returning the list of elements to append to the containing list
  ; ~@a -> a
  ; ~@[a b c] -> [a b c]
  ; ~@(a b c) -> [a b c]
  (fn unquote-splicing-expand (node)
    (if (ast.symbol? node) node
    (if (ast.array? node)
      node
      (R.map R.identity node))))

  ; Takes a list/array and applies quoting to it, while honoring unquotes and unquote-splicings
  ; (unquote a) -> [a]
  ; (unquote-splicing a) -> a
  ; a -> [(quote a)]
  (fn sequence-expand (nodes)
      (R.apply L (.concat [(S ".concat")]
        (R.map (fn (node)
          (if (ast.unquote? node) [(R.nth 1 node)]
            (if (ast.unquote-splicing? node)
              (unquote-splicing-expand (R.nth 1 node))
              [(L (S "quote") node)]))) nodes))))

  (if (ast.symbol? node) (L (S "quote") node)
  (if (ast.keyword? node) (L (S "quote") node)
  (if (ast.string? node) node
  (if (ast.number? node) node
  (if (ast.boolean? node) node
  (if (ast.null? node) node
  (if (ast.undefined? node) node
  (if (ast.unquote? node) (R.nth 1 node)
  (if (ast.unquote-splicing? node)
    (throw (Error. "Illegal use of `~@` expression, can only be present in a list"))
  (if (R.empty? node) node
  (if (ast.array? node) (sequence-expand node)
  (if (ast.object? node) (R.mapObjIndexed (fn (v) (L (S "quote") v)))
  (if (ast.list? node) (L (S "apply") (S "list") (sequence-expand node))
  (throw (Error. (+ "Unhandled ast node type given to 'quote', got: " (ast.print node))))
  ))))))))))))))

; For now quote behaves like quasi-quote should, just use that
(defmacro quasi-quote (node)
  (ast.list (ast.symbol "quote") node))

(defmacro defn (name params ... body)
  `(def name (fn ~name ~params ~@body)))

(defmacro let (definitions ... body)
  `(do ~@(map (fn (d) (prepend 'def d)) definitions) ~@body))

(defmacro package (name params ... body)
  ; WIP
  `(def name (fn ~name ~params ~@body)))

