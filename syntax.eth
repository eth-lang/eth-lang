(import "./ast" ast)

; Quotes the given AST preventing it's evaluation. This is, while taking care of honoring
; unquotes and unquote-splicings
(defmacro quote (node)
  (def L ast.list)
  (def S ast.symbol)

  ; Takes a node a unquote it, returning the list of elements to append to the containing list
  ; ~@a -> a
  ; ~@[a b c] -> [a b c]
  ; ~@(a b c) -> [a b c]
  (def unquote-splicing-expand (fn (node)
    (if (ast.symbol? node) node
    (if (ast.array? node)
      node
      (map identity node)))))

  ; Takes a list/array and applies quoting to it, while honoring unquotes and unquote-splicings
  ; (unquote a) -> [a]
  ; (unquote-splicing a) -> a
  ; a -> [(quote a)]
  (def sequence-expand (fn (nodes)
      (apply L (.concat [(S ".concat")]
        (map (fn (node)
          (if (ast.unquote? node) [(nth 1 node)]
            (if (ast.unquote-splicing? node)
              (unquote-splicing-expand (nth 1 node))
              [(L (S "quote") node)]))) nodes)))))

  (if (ast.symbol? node) (L (S "quote") node)
  (if (ast.keyword? node) (L (S "quote") node)
  (if (ast.string? node) node
  (if (ast.number? node) node
  (if (ast.boolean? node) node
  (if (ast.null? node) node
  (if (ast.undefined? node) node
  (if (empty? node) node
  (if (ast.unquote? node) (nth 1 node)
  (if (ast.unquote-splicing? node)
    (throw (Error. "Illegal use of `~@` expression, can only be present in a list"))
  (if (ast.array? node) (sequence-expand node)
  (if (ast.object? node) (mapObjIndexed (fn (v) (L (S "quote") v)))
  (if (ast.list? node) (L (S "apply") (S "list") (sequence-expand node))
  (throw (Error. (+ "Unhandled ast node type given to 'quote', got: " (ast.print node))))
  ))))))))))))))

; For now quote behaves like quasi-quote should, just use that
(defmacro quasi-quote (node)
  (ast.list (ast.symbol "quote") node))

(defmacro defn (name params ... body)
  `(def ~name (fn ~name ~params ~@body)))

(defmacro let (definitions ... body)
  `(do ~@(map (fn (d) (prepend 'def d)) definitions) ~@body))

(defmacro export (name value)
  `(set (get ~name __eth__module) ~value))

(defmacro package (name exports ... body)
  `(do
    (def __eth__module {})
    ~@body
    ~@(map (fn (e) `(export ~(keyword e) ~e)) exports)
    (if (!= (typeof module) "undefined")
      (set (get :exports module) __eth__module))
    (if (!= (typeof window) "undefined")
      (set (get ~(symbol-name name) window) __eth__module))
    (void 0)))

(defmacro \ (... body)
  `(fn () ~@(ast-map-node (fn (node)
    (if (symbol? node)
      (let ((sym-name (symbol-name node))
            (sym-arg? (regexp-find "^\#\d$" sym-name)))
        (if (== sym-name "#")
          `(get 0 arguments)
          (if sym-arg?
            `(get ~(- (parse-int (.slice sym-name 1)) 1) arguments)
            node)))
      node)) body)))
