(package eth/core (of-type? null? undefined? boolean? number? string? object? array? function?
                   string array object type and or
                   assert not apply curry curry2 curry3 curryN
                   add sub mul div mod
                   PI abs ceil floor log sin cos tan pow max min round sqrt inc dec random even? odd?
                   len head tail last concat cons append map reduce filter for-each contains join
                   print identity always
                   from-json to-json
                   prop prop-eq pick keys values merge clone assoc get-in set-in update-in)

; types

(defn type (x)
  (if (Array.isArray x) :array
    (if (== x null) :null
      (typeof x))))

(defn of-type? (t value)
  (== (type value) t))

(defn null? (value)
  (of-type? :null value))

(defn undefined? (value)
  (of-type? :undefined value))

(defn boolean? (value)
  (of-type? :boolean value))

(defn number? (value)
  (of-type? :number value))

(defn string? (value)
  (of-type? :string value))

(defn object? (value)
  (of-type? :object value))

(defn array? (value)
  (of-type? :array value))

(defn function? (value)
  (of-type? :function value))

; basics

(defn assert (c ... messages)
  (if (! c)
    (throw (Error. (+ "Assertion Error: " (messages.join ""))))
    ()))

(defn not (x)
  (! x))

(defn apply (f args)
  (assert (of-type? :function f) "core: apply: needs it's 1st arg to be a function")
  (f.apply null args))

(defn curry (f ... base-args) (fn (... args)
  (apply f (Array.prototype.concat.call base-args args))))
(defn curry2 () (fn (f) (fn (arg1) (fn (arg2) (f arg1 arg2)))))
(defn curry3 () (fn (f) (fn (arg1) (fn (arg2) (fn (arg3) (f arg1 arg2 arg3))))))
(defn curryN (n f args)
  (fn ()
    (set new-args (Array.prototype.slice.call arguments))
    (let ((merged-args ((get :concat (|| args [])) new-args)))
        (if (>= (get :length merged-args) n)
          (apply f merged-args)
          (curryN n f merged-args)))))

; math

(def PI Math.PI)
(def abs Math.abs)
(def ceil Math.ceil)
(def floor Math.floor)
(def log Math.log)
(def sin Math.sin)
(def cos Math.cos)
(def tan Math.tan)
(def pow Math.pow)
(def max Math.max)
(def min Math.min)
(def round Math.round)
(def sqrt Math.sqrt)
(defn inc (x) (+ x 1))
(defn dec (x) (- x 1))

(defn random (x)
  (if x (round (* (Math.random) x)) (Math.random)))

(defn even? (x)
  (== (% x 2) 0))

(defn odd? (x)
  (== (% x 2) 1))

; lists

(defn len (l)
  (get :length l))


(defn head (l)
  (if (> (len l) 0)
    (get 0 l)
    null))


(defn tail (l)
  (if (> (len l) 0)
    (Array.prototype.slice.call l 1)
    []))


(defn last (l)
  (if (> (len l) 0)
    (. (dec (len l)) l)
    null))


(defn concat (l1 l2)
  (Array.prototype.concat.call l1 l2))
(set concat (curryN 2 concat))


(defn cons (a l)
  (concat [a] l))
(set cons (curryN 2 cons))


(defn append (a l)
  (concat l [a]))
(set append (curryN 2 append))


(defn map (f iterable)
  (set ret [])
  (while (< (len ret) (len iterable))
    (set (. (len ret) ret) (f (. (len ret) iterable))))
  ret)
(set map (curryN 2 map))


(defn reduce (f init iterable)
  (set acc init)
  (set i 0)
  (while (< i (len iterable))
    (set acc (f acc (. i iterable)))
    (set i (inc i)))
  acc)
(set reduce (curryN 3 reduce))

(defn filter (f iterable)
  (set ret [])
  (set i 0)
  (while (< i (len iterable))
    (if (f (. i iterable))
      (set ret (append (. i iterable) ret))
      ())
    (set i (inc i)))
  ret)
(set filter (curryN 2 filter))


(defn for-each (f iterable)
  (map f iterable)
  ())
(set for-each (curryN 2 for-each))


(defn contains (x xs)
  (> (xs.index-of x) -1))


(defn join (sep xs)
  (xs.join sep))
(set join (curryN 2 join))


; basic math

(defn add ()
  (reduce (fn (acc a) (+ acc a)) 0 arguments))

(defn sub ()
  (assert (>= (len arguments) 2) "'sub' takes a minimum of 2 arguments")
  (reduce (fn (acc a) (- acc a)) (head arguments) (tail arguments)))

(defn mul ()
  (reduce (fn (acc a) (* acc a)) 1 arguments))

(defn div ()
  (reduce (fn (acc a) (/ acc a)) 1 arguments))

(setn mod (curryN 2 (fn (x y) (% x y))))

; types (continued)

(defn string ()
  (reduce (fn (acc a) (+ acc a)) "" arguments))

(defn array ()
  (Array.prototype.slice.call arguments))

(defn object (... keys-and-vals)
  (assert (even? (len keys-and-vals)) "'object' needs a even number of elements")
  (let ((ret {})
        (i 0))
    (while (< i (len keys-and-vals))
      (set (. i keys-and-vals) (. (inc i) keys-and-vals)))))

(defn and ()
  (assert (>= (len arguments) 2) "'and' takes a minimum of 2 arguments")
  (reduce (fn (a b) (&& a b)) (head arguments) (tail arguments)))
(defn or ()
  (assert (>= (len arguments) 2) "'or' takes a minimum of 2 arguments")
  (reduce (fn (a b) (|| a b)) (head arguments) (tail arguments)))

(defn print ()
  (apply console.log arguments))

(defn identity (a)
  a)

(defn always (a)
  (fn ()
    a))

; json

; parse a json string to a javascript value
(defn from-json (s)
  (JSON.parse s))

; takes a value to convert to a json string and optionnaly true or the indentation level wanted for
; pretty printing
(defn to-json (value pretty-print)
  (if pretty-print
    (JSON.stringify value null (if (== pretty-print true) 2 pretty-print))
    (JSON.stringify value)))


; objects

(defn prop-eq (key value)
  (fn (obj)
    (== (get key obj) value)))


(defn prop (key)
  (fn (obj)
    (get key obj)))


(defn pick (ks obj)
  (assert (of-type? :array ks) "eth/core: pick: need an array of keys, got: " (to-json ks))
  (assert (of-type? :object ks) "eth/core: pick: need an object as 2nd argument, got: " (to-json obj))
  (let ((ret {})
        (set-value (fn (k) (set (get k ret) (get k obj)))))
    (for-each set-value ks)))


(defn keys (o)
  (Object.keys o))


(defn values (o)
  (map (fn (key) (get key o)) (keys o)))


(defn merge (o1 o2)
  (let ((ret {})
        (setter (fn (o) (fn (k) (set (get k ret) (get k o))))))
    (for-each (setter o1) (keys o1))
    (for-each (setter o2) (keys o2))
    ret))


(defn clone (a)
  (let ((t (type a)))
    (if (== t "array") (map identity a)
    (if (== t "object") (merge {} a)
    a))))


(defn assoc (key value obj)
  (let ((shallow-copy (clone obj)))
    (set (get key shallow-copy) value)
    shallow-copy))


(defn get-in (path obj)
  (if (== (len path) 0)
    obj
    (get-in (tail path) (get (head path) obj))))


(defn set-in (path value obj)
  (if (== (len path) 0)
    value
    (assoc
      (head path)
      (set-in (tail path) value (get (head path) obj))
      obj)))


(defn update-in (path update-fn obj)
  (set-in path (update-fn (get-in path obj)) obj))

)
