(package eth/core (of-type? null? undefined? boolean? number? string? object? array? function?
                   string array object type and or
                   assert not apply curry curry2 curry3 curryN
                   add sub mul div mod
                   PI abs ceil floor log sin cos tan pow max min round sqrt inc dec random even? odd?
                   len head tail last concat cons append map reduce filter for-each contains join
                   print identity always
                   from-json to-json
                   prop prop-eq pick keys values merge clone assoc get-in set-in update-in)

; types

(def type (x)
  (if (Array.isArray x) :array
    (if (== x null) :null
      (typeof x))))

(def of-type? (t value)
  (== (type value) t))

(def null? (value)
  (of-type? :null value))

(def undefined? (value)
  (of-type? :undefined value))

(def boolean? (value)
  (of-type? :boolean value))

(def number? (value)
  (of-type? :number value))

(def string? (value)
  (of-type? :string value))

(def object? (value)
  (of-type? :object value))

(def array? (value)
  (of-type? :array value))

(def function? (value)
  (of-type? :function value))

; basics

(def assert (c ... messages)
  (if (! c)
    (throw (Error. (+ "Assertion Error: " (messages.join ""))))
    ()))

(def not (x)
  (! x))

(def apply (f args)
  (assert (of-type? :function f) "core: apply: needs it's 1st arg to be a function")
  (f.apply null args))

(def curry (f ... base-args) (fn (... args)
  (apply f (Array.prototype.concat.call base-args args))))
(def curry2 () (fn (f) (fn (arg1) (fn (arg2) (f arg1 arg2)))))
(def curry3 () (fn (f) (fn (arg1) (fn (arg2) (fn (arg3) (f arg1 arg2 arg3))))))
(def curryN (n f args)
  (fn ()
    (set new-args (Array.prototype.slice.call arguments))
    (let ((merged-args ((. :concat (|| args [])) new-args)))
        (if (>= (. :length merged-args) n)
          (apply f merged-args)
          (curryN n f merged-args)))))

; math

(set PI Math.PI)
(set abs Math.abs)
(set ceil Math.ceil)
(set floor Math.floor)
(set log Math.log)
(set sin Math.sin)
(set cos Math.cos)
(set tan Math.tan)
(set pow Math.pow)
(set max Math.max)
(set min Math.min)
(set round Math.round)
(set sqrt Math.sqrt)
(def inc (x) (+ x 1))
(def dec (x) (- x 1))

(def random (x)
  (if x (round (* (Math.random) x)) (Math.random)))

(def even? (x)
  (== (% x 2) 0))

(def odd? (x)
  (== (% x 2) 1))

; lists

(def len (l)
  (. :length l))


(def head (l)
  (if (> (len l) 0)
    (. 0 l)
    null))


(def tail (l)
  (if (> (len l) 0)
    (Array.prototype.slice.call l 1)
    []))


(def last (l)
  (if (> (len l) 0)
    (. (dec (len l)) l)
    null))


(def concat (l1 l2)
  (Array.prototype.concat.call(l1, l2)))
(set concat (curryN 2 concat))


(def cons (a l)
  (concat [a] l))
(set cons (curryN 2 cons))


(def append (a l)
  (concat l [a]))
(set append (curryN 2 append))


(def map (f iterable)
  (set ret [])
  (while (< (len ret) (len iterable))
    (set (. (len ret) ret) (f (. (len ret) iterable))))
  ret)
(set map (curryN 2 map))


(def reduce (f init iterable)
  (set acc init)
  (set i 0)
  (while (< i (len iterable))
    (set acc (f acc (. i iterable)))
    (set i (inc i)))
  acc)
(set reduce (curryN 3 reduce))

(def filter (f iterable)
  (set ret [])
  (set i 0)
  (while (< i (len iterable))
    (if (f (. i iterable))
      (set ret (append (. i iterable) ret))
      ())
    (set i (inc i)))
  ret)
(set filter (curryN 2 filter))


(def for-each (f iterable)
  (map f iterable)
  ())
(set for-each (curryN 2 for-each))


(def contains (x xs)
  (> (xs.index-of x) -1))


(def join (sep xs)
  (xs.join sep))
(set join (curryN 2 join))


; basic math

(def add ()
  (reduce (fn (acc a) (+ acc a)) 0 arguments))

(def sub ()
  (assert (>= (len arguments) 2) "'sub' takes a minimum of 2 arguments")
  (reduce (fn (acc a) (- acc a)) (head arguments) (tail arguments)))

(def mul ()
  (reduce (fn (acc a) (* acc a)) 1 arguments))

(def div ()
  (reduce (fn (acc a) (/ acc a)) 1 arguments))

(set mod (curryN 2 (fn (x y) (% x y))))

; types (continued)

(def string ()
  (reduce (fn (acc a) (+ acc a)) "" arguments))

(def array ()
  (Array.prototype.slice.call arguments))

(def object (... keys-and-vals)
  (assert (even? (len keys-and-vals)) "'object' needs a even number of elements")
  (let ((ret {})
        (i 0))
    (while (< i (len keys-and-vals))
      (set (. i keys-and-vals) (. (inc i) keys-and-vals)))))

(def and ()
  (assert (>= (len arguments) 2) "'and' takes a minimum of 2 arguments")
  (reduce (fn (a b) (&& a b)) (head arguments) (tail arguments)))
(def or ()
  (assert (>= (len arguments) 2) "'or' takes a minimum of 2 arguments")
  (reduce (fn (a b) (|| a b)) (head arguments) (tail arguments)))

(def print ()
  (apply console.log arguments))

(def identity (a)
  a)

(def always (a)
  (fn ()
    a))

; json

; parse a json string to a javascript value
(def from-json (s)
  (JSON.parse s))

; takes a value to convert to a json string and optionnaly true or the indentation level wanted for
; pretty printing
(def to-json (value pretty-print)
  (if pretty-print
    (JSON.stringify value null (if (== pretty-print true) 2 pretty-print))
    (JSON.stringify value)))


; objects

(def prop-eq (key value)
  (fn (obj)
    (== (get key obj) value)))


(def prop (key)
  (fn (obj)
    (get key obj)))


(def pick (ks obj)
  (assert (of-type? :array ks) "eth/core: pick: need an array of keys, got: " (to-json ks))
  (assert (of-type? :object ks) "eth/core: pick: need an object as 2nd argument, got: " (to-json obj))
  (let ((ret {})
        (set-value (fn (k) (set (. k ret) (get k obj)))))
    (for-each set-value ks)))


(def keys (o)
  (Object.keys o))


(def values (o)
  (map (fn (key) (. key o)) (keys o)))


(def merge (o1 o2)
  (let ((ret {})
        (setter (fn (o) (fn (k) (set (. k ret) (. k o))))))
    (for-each (setter o1) (keys o1))
    (for-each (setter o2) (keys o2))
    ret))


(def clone (a)
  (let ((t (type a)))
    (if (== t "array") (map identity a)
    (if (== t "object") (merge {} a)
    a))))


(def assoc (key value obj)
  (let ((shallow-copy (clone obj)))
    (set (. key shallow-copy) value)
    shallow-copy))


(def get-in (path obj)
  (if (== (len path) 0)
    obj
    (get-in (tail path) (get (head path) obj))))


(def set-in (path value obj)
  (if (== (len path) 0)
    value
    (assoc
      (head path)
      (set-in (tail path) value (get (head path) obj))
      obj)))


(def update-in (path update-fn obj)
  (set-in path (update-fn (get-in path obj)) obj))

)
